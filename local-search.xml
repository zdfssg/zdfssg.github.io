<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/2021/03/08/vue/"/>
    <url>/2021/03/08/vue/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Vue？"><a href="#什么是Vue？" class="headerlink" title="什么是Vue？"></a>什么是Vue？</h3><p>Vue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h3 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h3><p>1.引入vue.js<br>2.创建挂载节点标签(不能挂载到body和html标签上)<br>3.实例化Vue对象<br>    el:挂载节点的选择器<br>    data:数据对象</p><h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><h4 id="指令是什么？"><a href="#指令是什么？" class="headerlink" title="指令是什么？"></a>指令是什么？</h4><p>指令就是自定义属性</p><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>1.v-html: 渲染内容,可以编译html字符串<br>2.v-text: 渲染内容,不能编译html字符串<br>3.v-cloak: 防止闪动<br>4.v-pre: 跳过编译<br>5.v-once: 一次性绑定<br>6.v-on: 事件绑定<br>7.v-bind: 属性绑定<br>8.v-model: 双向绑定</p><h3 id="Vue事件"><a href="#Vue事件" class="headerlink" title="Vue事件"></a>Vue事件</h3><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p>&lt;标签 v-on:事件类型 = “事件函数” /&gt;<br>&lt;标签 @事件类型 = “事件函数” /&gt;</p><h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><p>&lt;标签 v-on:事件类型 = “事件函数(实参,$event)” /&gt;<br>$event表示事件绑定对象</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">new Vue(</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    el:&#x27;&#x27;,</span><br><span class="hljs-template-variable">    data:&#x27;&#x27;,</span><br><span class="hljs-template-variable">    methods:&#123;</span><br><span class="hljs-template-variable">        事件函数(形参,e)</span><br><span class="hljs-template-variable">    &#125;</span><br><span class="xml">&#125;)</span><br><br><span class="xml">#### 事件修饰符</span><br><span class="xml">1. .stop</span><br><span class="xml">2. .prevent</span><br><span class="xml">3. .capture</span><br><span class="xml">4. .self</span><br><span class="xml">5. .once</span><br><span class="xml">6. .passive</span><br><span class="xml">```html</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop.prevent</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.capture</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.self</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">```<br><span class="hljs-comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。</p><h5 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h5><p>为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.page-down</span>=<span class="hljs-string">&quot;onPageDown&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p><ul><li>.enter</li><li>.tab</li><li>.delete (捕获“删除”和“退格”键)</li><li>.esc</li><li>.space</li><li>.up</li><li>.down</li><li>.left</li><li>.right<br>有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。<br>你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名：<br>···html<br>// 可以使用 <code>v-on:keyup.f1</code><br>Vue.config.keyCodes.f1 = 112<pre><code></code></pre></li></ul><h3 id="Vue样式"><a href="#Vue样式" class="headerlink" title="Vue样式"></a>Vue样式</h3><p>1.class<br>    对象：&lt;标签 :class=”{class名1:变量名1,class名2:变量名2}”/&gt;<br>    数组: &lt;标签 :class=”[变量名1,变量名2,’class名1’,’class名2’]”/&gt;<br>    属性绑定: &lt;标签 class=”条件? ‘class名1’:’class名2’”/&gt;<br>2.style<br>    对象: &lt;标签 :style=”{css属性名:变量名1 }” /&gt;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>session和jwt身份认证</title>
    <link href="/2021/02/27/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <url>/2021/02/27/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>1.什么是身份认证<br>身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。<br>⚫ 日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或指纹解锁，支付宝或微信的支付密码等。<br>⚫ 在 Web 开发中，也涉及到用户身份的认证，例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等。</p><p>2.不同开发模式下的身份认证<br>① 服务端渲染推荐使用 Session 认证机制<br>② 前后端分离推荐使用 JWT 认证机制</p><ol><li><p>Session 认证机制</p></li><li><p>HTTP 协议的无状态性<br>了解 HTTP 协议的无状态性是进一步学习 Session 认证机制的必要前提。<br>HTTP 协议的无状态性，指的是客户端的每次 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会<br>主动保留每次 HTTP 请求的状态</p></li><li><p>如何突破 HTTP 无状态的限制<br>现实生活中的会员卡身份认证方式，在 Web 开发中的专业术语叫做 Cookie。</p></li><li><p>什么是 Cookie<br>Cookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用<br>于控制 Cookie 有效期、安全性、使用范围的可选属性组成。<br>不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。<br>Cookie的几大特性：<br>① 自动发送<br>② 域名独立<br>③ 过期时限<br>④ 4KB 限制</p></li><li><p>Cookie 在身份认证中的作用<br>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动<br>将 Cookie 保存在浏览器中。<br>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给<br>服务器，服务器即可验明客户端的身份。</p></li></ol><ol start="5"><li><p>Cookie 不具有安全性<br>由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全<br>性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。</p></li><li><p>Session 的工作原理</p></li></ol><p>7.在 Express 中使用 Session 认证</p><ol><li>安装 express-session 中间件</li></ol><p>npm install express-session<br>1<br>2.配置中间件</p><p>// 导入 express 模块<br>const express = require(‘express’)<br>// 创建 express 的服务器实例<br>const app = express()</p><p>// TODO_01：请配置 Session 中间件<br>const session = require(‘express-session’)<br>app.use(<br>  session({<br>    secret: ‘itheima’,//属性值为任意字符<br>    resave: false,//固定写法<br>    saveUninitialized: true,//固定写法<br>  })<br>)</p><p>3.向session中缓存数据</p><p>app.post(‘/api/login’, (req, res) =&gt; {<br>  // 判断用户提交的登录信息是否正确<br>  if (req.body.username !== ‘admin’ || req.body.password !== ‘000000’) {<br>    return res.send({ status: 1, msg: ‘登录失败’ })<br>  }</p><p>  // TODO_02：请将登录成功后的用户信息，保存到 Session 中<br>  // 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性<br>  req.session.user = req.body // 用户的信息<br>  req.session.islogin = true // 用户的登录状态</p><p>  res.send({ status: 0, msg: ‘登录成功’ })<br>})</p><p>4.从 session 中取数据</p><p>app.get(‘/api/username’, (req, res) =&gt; {<br>  // TODO_03：请从 Session 中获取用户的名称，响应给客户端<br>  if (!req.session.islogin) {<br>    return res.send({ status: 1, msg: ‘fail’ })<br>  }<br>  res.send({<br>    status: 0,<br>    msg: ‘success’,<br>    username: req.session.user.username,<br>  })<br>})</p><p>5.清空session</p><p>// 退出登录的接口<br>app.post(‘/api/logout’, (req, res) =&gt; {<br>  // TODO_04：清空 Session 信息<br>  req.session.destroy()<br>  res.send({<br>    status: 0,<br>    msg: ‘退出登录成功’,<br>  })<br>})</p><p>7.session测试代码<br>// 导入 express 模块<br>const express = require(‘express’)<br>// 创建 express 的服务器实例<br>const app = express()</p><p>// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt<br>const jwt = require(‘jsonwebtoken’)<br>const expressJWT = require(‘express-jwt’)</p><p>// 允许跨域资源共享<br>const cors = require(‘cors’)<br>app.use(cors())</p><p>// 解析 post 表单数据的中间件<br>const bodyParser = require(‘body-parser’)<br>app.use(bodyParser.urlencoded({ extended: false }))</p><p>// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey<br>const secretKey = ‘itheima No1 ^_^’</p><p>// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件<br>// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上<br>app.use(expressJWT({ secret: secretKey }).unless({ path: [/^/api//] }))</p><p>// 登录接口<br>app.post(‘/api/login’, function (req, res) {<br>  // 将 req.body 请求体中的数据，转存为 userinfo 常量<br>  const userinfo = req.body<br>  // 登录失败<br>  if (userinfo.username !== ‘admin’ || userinfo.password !== ‘000000’) {<br>    return res.send({<br>      status: 400,<br>      message: ‘登录失败！’,<br>    })<br>  }<br>  // 登录成功<br>  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端<br>  // 参数1：用户的信息对象<br>  // 参数2：加密的秘钥<br>  // 参数3：配置对象，可以配置当前 token 的有效期<br>  // 记住：千万不要把密码加密到 token 字符中<br>  const tokenStr = jwt.sign({ username: userinfo.username }, secretKey, { expiresIn: ‘30s’ })<br>  res.send({<br>    status: 200,<br>    message: ‘登录成功！’,<br>    token: tokenStr, // 要发送给客户端的 token 字符串<br>  })<br>})</p><p>// 这是一个有权限的 API 接口<br>app.get(‘/admin/getinfo’, function (req, res) {<br>  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端<br>  console.log(req.user)<br>  res.send({<br>    status: 200,<br>    message: ‘获取用户信息成功！’,<br>    data: req.user, // 要发送给客户端的用户信息<br>  })<br>})</p><p>// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误<br>app.use((err, req, res, next) =&gt; {<br>  // 这次错误是由 token 解析失败导致的<br>  if (err.name === ‘UnauthorizedError’) {<br>    return res.send({<br>      status: 401,<br>      message: ‘无效的token’,<br>    })<br>  }<br>  res.send({<br>    status: 500,<br>    message: ‘未知的错误’,<br>  })<br>})</p><p>// 调用 app.listen 方法，指定端口号并启动web服务器<br>app.listen(8888, function () {<br>  console.log(‘Express server running at <a href="http://127.0.0.1:8888&#39;">http://127.0.0.1:8888&#39;</a>)<br>})</p><ol start="2"><li><p>JWT 认证机制</p></li><li><p>了解 Session 认证的局限性<br>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接<br>口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。<br>注意：<br>⚫ 当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。<br>⚫ 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。</p></li><li><p>什么是 JWT<br>JWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。</p></li></ol><p>3.JWT 工作原理</p><ol start="4"><li>JWT 的组成部分<br>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。<br>三者之间使用英文的“.”分隔，格式如下：</li></ol><p>Header.Payload.Signature</p><p>⚫Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。<br>⚫ Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。</p><ol start="5"><li>JWT 的使用方式<br>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。<br>此后，客户端每次与服务器通信，都要带上这个 JWT 的字符串，从而进行身份认证。推荐的做法是把 JWT 放在 HTTP<br>请求头的 Authorization 字段中，格式如下：</li></ol><p>Authorization:Bearer<token></p><ol start="6"><li>安装 JWT 相关的包<br>install jsonwebtoken express-jwt</li></ol><p>⚫ jsonwebtoken 用于生成 JWT 字符串<br>⚫ express-jwt 用于将 JWT 字符串解析还原成 JSON 对象</p><p>// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt<br>const jwt = require(‘jsonwebtoken’)<br>const expressJWT = require(‘express-jwt’)</p><p>7.定义密匙<br>// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey<br>const secretKey = ‘itheima No1 ^_^’</p><p>8.登陆成功生成JWT 字符串<br>// 登录成功<br>  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端<br>  // 参数1：用户的信息对象<br>  // 参数2：加密的秘钥<br>  // 参数3：配置对象，可以配置当前 token 的有效期<br>  // 记住：千万不要把密码加密到 token 字符中<br>  const tokenStr = jwt.sign({ username: userinfo.username }, secretKey, { expiresIn: ‘30s’ })<br>  res.send({<br>    status: 200,<br>    message: ‘登录成功！’,<br>    token: tokenStr, // 要发送给客户端的 token 字符串</p><p>8.注册将 JWT 字符串解析还原成 JSON 对象的中间件<br>app.use(expressJWT({ secret: secretKey }).unless({ path: [/^/api//] }))</p><ol start="9"><li>使用 req.user 获取用户信息<br>当 express-jwt 这个中间件配置成功之后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串<br>中解析出来的用户信息了，示例代码如下：</li></ol><p>// 这是一个有权限的 API 接口<br>app.get(‘/admin/getinfo’, function (req, res) {<br>  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端<br>  console.log(req.user)<br>  res.send({<br>    status: 200,<br>    message: ‘获取用户信息成功！’,<br>    data: req.user, // 要发送给客户端的用户信息<br>  })<br>})</p><p>7.使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误<br>app.use((err, req, res, next) =&gt; {<br>  // 这次错误是由 token 解析失败导致的<br>  if (err.name === ‘UnauthorizedError’) {<br>    return res.send({<br>      status: 401,<br>      message: ‘无效的token’,<br>    })<br>  }<br>  res.send({<br>    status: 500,<br>    message: ‘未知的错误’,<br>  })<br>})</p><p>jwt测试 .js 代码</p><p>// 导入 express 模块<br>const express = require(‘express’)<br>// 创建 express 的服务器实例<br>const app = express()</p><p>// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt<br>const jwt = require(‘jsonwebtoken’)<br>const expressJWT = require(‘express-jwt’)</p><p>// 允许跨域资源共享<br>const cors = require(‘cors’)<br>app.use(cors())</p><p>// 解析 post 表单数据的中间件<br>const bodyParser = require(‘body-parser’)<br>app.use(bodyParser.urlencoded({ extended: false }))</p><p>// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey<br>const secretKey = ‘itheima No1 ^_^’</p><p>// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件<br>// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上<br>app.use(expressJWT({ secret: secretKey }).unless({ path: [/^/api//] }))</p><p>// 登录接口<br>app.post(‘/api/login’, function (req, res) {<br>  // 将 req.body 请求体中的数据，转存为 userinfo 常量<br>  const userinfo = req.body<br>  // 登录失败<br>  if (userinfo.username !== ‘admin’ || userinfo.password !== ‘000000’) {<br>    return res.send({<br>      status: 400,<br>      message: ‘登录失败！’,<br>    })<br>  }<br>  // 登录成功<br>  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端<br>  // 参数1：用户的信息对象<br>  // 参数2：加密的秘钥<br>  // 参数3：配置对象，可以配置当前 token 的有效期<br>  // 记住：千万不要把密码加密到 token 字符中<br>  const tokenStr = jwt.sign({ username: userinfo.username }, secretKey, { expiresIn: ‘30s’ })<br>  res.send({<br>    status: 200,<br>    message: ‘登录成功！’,<br>    token: tokenStr, // 要发送给客户端的 token 字符串<br>  })<br>})</p><p>// 这是一个有权限的 API 接口<br>app.get(‘/admin/getinfo’, function (req, res) {<br>  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端<br>  console.log(req.user)<br>  res.send({<br>    status: 200,<br>    message: ‘获取用户信息成功！’,<br>    data: req.user, // 要发送给客户端的用户信息<br>  })<br>})</p><p>// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误<br>app.use((err, req, res, next) =&gt; {<br>  // 这次错误是由 token 解析失败导致的<br>  if (err.name === ‘UnauthorizedError’) {<br>    return res.send({<br>      status: 401,<br>      message: ‘无效的token’,<br>    })<br>  }<br>  res.send({<br>    status: 500,<br>    message: ‘未知的错误’,<br>  })<br>})</p><p>// 调用 app.listen 方法，指定端口号并启动web服务器<br>app.listen(8888, function () {<br>  console.log(‘Express server running at <a href="http://127.0.0.1:8888&#39;">http://127.0.0.1:8888&#39;</a>)<br>})<br>————————————————<br>版权声明：本文为CSDN博主「洋十三」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u012138854/article/details/109805603">https://blog.csdn.net/u012138854/article/details/109805603</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 第三方包</title>
    <link href="/2021/02/26/Node.js%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/"/>
    <url>/2021/02/26/Node.js%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js-第三方包"><a href="#Node-js-第三方包" class="headerlink" title="Node.js 第三方包"></a>Node.js 第三方包</h1><blockquote><p>常用的 <code>npm</code> 第三方包使用说明. 总结如下</p></blockquote><h3 id="1-cors-包"><a href="#1-cors-包" class="headerlink" title="1. cors 包"></a>1. <code>cors</code> 包</h3><ul><li><p>作用</p><p><code>cors</code>是一个 <code>node.js</code> 软件包，用于提供跨域资源请求的中间件</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i cors<br></code></pre></td></tr></table></figure><ul><li>使用方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>)<br><span class="hljs-keyword">var</span> app = express()<br> <br><span class="hljs-comment">// 全局注册 cors 中间件</span><br>app.use(cors())<br> <br>app.get(<span class="hljs-string">&#x27;/products/:id&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  res.json(&#123;<span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;This is CORS-enabled for all origins!&#x27;</span>&#125;)<br>&#125;)<br> <br>app.listen(<span class="hljs-number">80</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;CORS-enabled web server listening on port 80&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>官方文档</p><p> <a href="https://www.npmjs.com/package/cors">cors</a></p></li></ul><h3 id="2-body-parser-包"><a href="#2-body-parser-包" class="headerlink" title="2. body-parser 包"></a>2. <code>body-parser</code> 包</h3><ul><li><p>作用</p><p><code>node.js</code> 的中间件,  专门用于解析发送 <code>post</code> 请求时请求体中的数据,  使用 <code>req.body</code> 属性即可获取解析后的对象</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i body-parser<br></code></pre></td></tr></table></figure><ul><li>使用方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<br><br><span class="hljs-keyword">var</span> app = express()<br> <br><span class="hljs-comment">// 解析 application/x-www-form-urlencoded 格式的请求体数据</span><br>app.use(bodyParser.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br> <br><span class="hljs-comment">// 解析 application/json 格式的请求体数据</span><br>app.use(bodyParser.json())<br> <br>app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-comment">// 响应解析后的请求体对象</span><br>  res.send(req.body)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>官方文档</p><p><a href="https://www.npmjs.com/package/body-parser">body-parser</a></p></li></ul><h3 id="3-mysql-包"><a href="#3-mysql-包" class="headerlink" title="3. mysql 包"></a>3. <code>mysql</code> 包</h3><ul><li><p>作用</p><p><code>npm</code> 上的第三方模块包, 为 <code>Node.js</code> 项目提供了连接和操作数据库的驱动</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i mysql<br></code></pre></td></tr></table></figure><ul><li><p>使用方法</p><ul><li>连接数据库-方法1(创建一个新连接)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mysql      = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>);<br>  <br>  <span class="hljs-keyword">var</span> connection = mysql.createConnection(&#123;<br>    host     : <span class="hljs-string">&#x27;example.org&#x27;</span>,<br>    user     : <span class="hljs-string">&#x27;bob&#x27;</span>,<br>    password : <span class="hljs-string">&#x27;secret&#x27;</span>,<br>    database : <span class="hljs-string">&#x27;my_db&#x27;</span><br>  &#125;);<br>  <br>  <span class="hljs-comment">// 2. 使用 query方法执行 sql 语句</span><br>  connection.query(<span class="hljs-string">&#x27;SELECT 1&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, results</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;<br>    <span class="hljs-comment">// connected!</span><br>  &#125;);<br></code></pre></td></tr></table></figure><ul><li>连接数据库-方法2 (创建一个连接池)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>);<br><span class="hljs-keyword">var</span> pool  = mysql.createPool(&#123;<br>  connectionLimit : <span class="hljs-number">10</span>,<br>  host            : <span class="hljs-string">&#x27;example.org&#x27;</span>,<br>  user            : <span class="hljs-string">&#x27;bob&#x27;</span>,<br>  password        : <span class="hljs-string">&#x27;secret&#x27;</span>,<br>  database        : <span class="hljs-string">&#x27;my_db&#x27;</span><br>&#125;);<br><br><span class="hljs-comment">// 使用 query方法执行 sql 语句</span><br>pool.query(<span class="hljs-string">&#x27;SELECT 1 + 1 AS solution&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, results</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;The solution is: &#x27;</span>, results[<span class="hljs-number">0</span>].solution);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>执行<code>SQL</code>语句的方法 :  <code>query(sql语句, [values], callback)</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 查询数据: ? 是一个占位符, 会被中括号中对应的值替换</span><br>db.query(<span class="hljs-string">&#x27;SELECT * FROM books WHERE author = ?&#x27;</span>, [<span class="hljs-string">&#x27;David&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, results</span>) </span>&#123;<br>  <span class="hljs-comment">// error 是查询中出现的错误</span><br>  <span class="hljs-comment">// results 是查询得到的所有结果</span><br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 更新数据: 多个 ? 占位符, 会按照出现的先后顺序依次被中括号中的值替换</span><br>db.query(<span class="hljs-string">&#x27;UPDATE users SET foo = ?, bar = ?, baz = ? WHERE id = ?&#x27;</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, userId], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, results</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 插入数据: 快速插入一条数据</span><br><span class="hljs-keyword">var</span> post  = &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Hello MySQL&#x27;</span>&#125;;<br>db.query(<span class="hljs-string">&#x27;INSERT INTO posts SET ?&#x27;</span>, post, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, results</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;<br>  <span class="hljs-comment">// ok!</span><br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 获取插入, 更新 和 删除语句执行后影响的行数</span><br>db.query(<span class="hljs-string">&#x27;DELETE FROM posts WHERE title = &quot;wrong&quot;&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, results</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;deleted &#x27;</span> + results.affectedRows + <span class="hljs-string">&#x27; rows&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>官方文档</p><p><a href="https://www.npmjs.com/package/mysql">mysql</a></p></li></ul><h3 id="4-bcryptjs-包"><a href="#4-bcryptjs-包" class="headerlink" title="4. bcryptjs 包"></a>4. <code>bcryptjs</code> 包</h3><ul><li><p>作用</p><p>密码不能以明文形式保存到数据库中，否则数据泄露密码就会被窃取,  密码一般加密存储.</p><p> <code>bcryptjs</code> 是一个第三方加密库，用来实现在 Node 环境下的密码加密</p></li><li><p>加盐(<strong>salt</strong>)</p><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为 “加盐”.</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i bcryptjs<br></code></pre></td></tr></table></figure><ul><li>使用方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bcrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;bcryptjs&#x27;</span>)<br><span class="hljs-comment">// .hashSync() 方法对明文密码 bacon 进行加盐加密, 盐值为 10 (数字越大,密码越不容易被破解)</span><br><span class="hljs-keyword">var</span> hash = bcrypt.hashSync(<span class="hljs-string">&#x27;bacon&#x27;</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// .compareSync(加密前的密码, 加密后的密码) 方法比较加密前后的密码是否匹配</span><br>bcrypt.compareSync(<span class="hljs-string">&quot;not_bacon&quot;</span>, hash) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ul><li><p>官方文档</p><p><a href="https://www.npmjs.com/package/bcryptjs">bcryptjs</a></p></li></ul><h3 id="5-jsonwebtoken-包"><a href="#5-jsonwebtoken-包" class="headerlink" title="5. jsonwebtoken 包"></a>5. <code>jsonwebtoken</code> 包</h3><ul><li><p>作用</p><p>常用于网站中用户的身份认证,  可以把用户信息加密后生成一个 <code>token</code> 令牌, 不推荐存放用户密码等数据 </p></li><li><p><code>JWT </code>原理</p><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">参考说明</a></p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i jsonwebtoken<br></code></pre></td></tr></table></figure><ul><li>使用方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>);<br><br><span class="hljs-keyword">var</span> privateKey = <span class="hljs-string">&#x27;seeyou&#x27;</span>; <span class="hljs-comment">// 私钥</span><br><span class="hljs-keyword">var</span> token = jwt.sign(&#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;xm&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-number">123</span>&#125;, privateKey, &#123;<br>    algorithm: <span class="hljs-string">&#x27;HS256&#x27;</span>, <span class="hljs-comment">// 加密算法</span><br>    expiresIn: <span class="hljs-string">&#x27;1h&#x27;</span> <span class="hljs-comment">// 过期时间</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><p>官方文档</p><p><a href="https://www.npmjs.com/package/jsonwebtoken">jsonwebtoken</a></p></li></ul><h3 id="6-express-jwt-包"><a href="#6-express-jwt-包" class="headerlink" title="6. express-jwt 包"></a>6. <code>express-jwt</code> 包</h3><ul><li><p>功能</p><p>提供给 <code>express</code> 的一个中间件, 可以验证 <code>JWT</code> 令牌是否有效, 并解码出 <code>JWT</code> 中用户信息挂载到 <code>req.user</code> 上</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i express-jwt<br></code></pre></td></tr></table></figure><ul><li>使用方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> app = express()<br><br><span class="hljs-keyword">var</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>);<br><br><span class="hljs-comment">// 全局注册 jwt 中间件</span><br><span class="hljs-comment">// secret 是生成 jwt 时的秘钥; alg 是生成 jwt 时的加密算法</span><br><span class="hljs-comment">// .unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口不需要进行 jwt 的身份认证</span><br>app.use(jwt(&#123; <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;seeyou&#x27;</span>, <span class="hljs-attr">algorithms</span>: [<span class="hljs-string">&#x27;HS256&#x27;</span>]&#125;).unless(&#123;<span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>]&#125;));<br><br><span class="hljs-comment">// jwt 解码后的用户信息通过 req.user 来进行获取</span><br>app.get(<span class="hljs-string">&#x27;/protected&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br>    res.send(req.user) <span class="hljs-comment">// &#123; username: &#x27;xm&#x27;, id: 123&#125;</span><br>&#125;);<br><br><span class="hljs-comment">// 解码 token 不合法时会抛出一个错误, 统一在错误中间件中进行处理</span><br>app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, req, res, next</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (err.name === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) &#123;<br>    res.status(<span class="hljs-number">401</span>).send(<span class="hljs-string">&#x27;invalid token...&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><p>官方文档 (**<code>npm</code> 文档没有更新, 参考最新的 <code>github</code> 文档 **)</p><p><a href="https://github.com/auth0/express-jwt">express-jwt</a>     </p></li></ul><h3 id="7-multer-包"><a href="#7-multer-包" class="headerlink" title="7. multer 包"></a>7. <code>multer</code> 包</h3><ul><li><p>作用</p><p><code>multer</code> 是 <code>node.js</code> 的中间件, 用来解析 <code>multipart/form-data</code> 格式提交的数据,  主要用于文件上传的场景;</p><p>文件一般不会直接存放在数据库, 影响查询效率,  更多的是把文件存储在本地,  再向数据库中存储本地文件的路径</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i multer<br></code></pre></td></tr></table></figure><ul><li>使用方法</li></ul><p>​    表单中 <strong>文本字段</strong> 解析处理后的数据被挂载到 <code>req.body</code> 属性上</p><p>​    表单中 <strong>文件字段</strong> 解析处理后的数据被挂载到 <code>req.file</code>属性上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> multer  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>)<br><br><span class="hljs-comment">// 创建 multer 的实例对象，通过 dest 属性指定上传文件的存放路径</span><br><span class="hljs-keyword">var</span> upload = multer(&#123; <span class="hljs-attr">dest</span>: path.join(__dirname, <span class="hljs-string">&#x27;../uploads&#x27;</span>) &#125;)<br><br><span class="hljs-keyword">var</span> app = express()<br><br><span class="hljs-comment">//  upload.single(&#x27;cover_img&#x27;) 表示对 cover_img 这个文件字段单独处理</span><br>app.post(<span class="hljs-string">&#x27;/profile&#x27;</span>, upload.single(<span class="hljs-string">&#x27;cover_img&#x27;</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-comment">// req.file对象 存放了的文件处理后的信息, </span><br>  <span class="hljs-comment">// 其中有 fieldname 属性: 表单提交时的字段名, filename 属性: 文件上传到本地后的默认文件名</span><br>  <span class="hljs-comment">// req.body对象 存放了文本字段解析后的值</span><br>&#125;)<br></code></pre></td></tr></table></figure><ul><li><p>官方文档</p><p><a href="https://www.npmjs.com/package/multer">multer</a></p></li></ul><h3 id="8-hapi-joi-包"><a href="#8-hapi-joi-包" class="headerlink" title="8. @hapi/joi 包"></a>8. <code>@hapi/joi</code> 包</h3><ul><li><p>作用</p><p>在实际开发中，前后端都需要对表单的数据进行合法性的验证，而且，后端做为数据合法性验证的最后 一个关口，在拦截非法数据方面，起到了至关重要的作用,  <code>joi</code> 是 推荐使用第三方数据验证模块</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i @hapi/joi<br></code></pre></td></tr></table></figure><ul><li>基本使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/** </span><br><span class="hljs-comment">  * string() 值必须是字符串 </span><br><span class="hljs-comment">  * alphanum() 值只能是包含 a-zA-Z0-9 的字符串 </span><br><span class="hljs-comment">  * min(length) 最小长度 </span><br><span class="hljs-comment">  * max(length) 最大长度 </span><br><span class="hljs-comment">  * required() 值是必填项，不能为 undefined </span><br><span class="hljs-comment">  * pattern(正则表达式) 值必须符合正则表达式的规则 </span><br><span class="hljs-comment">  * email() 符合邮箱格式</span><br><span class="hljs-comment">  * integer() 值为整数</span><br><span class="hljs-comment">  */</span><br><br><span class="hljs-comment">// 用户名的验证规则 </span><br><span class="hljs-keyword">const</span> username = joi.string().alphanum().min(<span class="hljs-number">1</span>).max(<span class="hljs-number">10</span>).required()<br><br><span class="hljs-comment">// 密码的验证规则 </span><br><span class="hljs-keyword">const</span> password = joi.string().pattern(<span class="hljs-regexp">/^[\S]&#123;6,12&#125;$/</span>).required()<br><br><span class="hljs-comment">// 邮箱验证规则</span><br><span class="hljs-keyword">const</span> email = joi.string().email().required()<br><br><span class="hljs-comment">// id 验证规则</span><br><span class="hljs-keyword">const</span> id = joi.number().integer().min(<span class="hljs-number">1</span>).required() <br></code></pre></td></tr></table></figure><ul><li><p>官方文档</p><p><a href="https://joi.dev/api/">Joi</a></p></li></ul><h3 id="9-escook-express-joi-包"><a href="#9-escook-express-joi-包" class="headerlink" title="9. @escook/express-joi 包"></a>9. <code>@escook/express-joi</code> 包</h3><ul><li><p>作用</p><p><code>express</code> 项目中对请求参数应用 <code>joi</code> 验证规则的中间件</p></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i @escook/express-joi<br></code></pre></td></tr></table></figure></li><li><p>使用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><span class="hljs-comment">// 导入 Joi 来定义验证规则</span><br><span class="hljs-keyword">const</span> Joi = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@hapi/joi&#x27;</span>)<br><span class="hljs-comment">// 1. 导入 @escook/express-joi</span><br><span class="hljs-keyword">const</span> expressJoi = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@escook/express-joi&#x27;</span>)<br> <br><span class="hljs-comment">// 解析 x-www-form-urlencoded 格式的表单数据</span><br>app.use(express.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br> <br><span class="hljs-comment">// 2. 定义验证规则</span><br><span class="hljs-comment">// 注意：如果客户端提交的某些参数项未在 schema 中定义，</span><br><span class="hljs-comment">// 此时，这些多余的参数项默认会被忽略掉</span><br><span class="hljs-keyword">const</span> userSchema = &#123;<br>  <span class="hljs-comment">// 2.1 校验 req.body 中的数据</span><br>  body: &#123;<br>    username: Joi.string().alphanum().min(<span class="hljs-number">3</span>).max(<span class="hljs-number">12</span>).required(),<br>    password: Joi.string().pattern(<span class="hljs-regexp">/^[\S]&#123;6,15&#125;$/</span>).required(),<br>    repassword: Joi.ref(<span class="hljs-string">&#x27;password&#x27;</span>),<br>  &#125;,<br>  <span class="hljs-comment">// 2.2 校验 req.query 中的数据</span><br>  query: &#123;<br>    name: Joi.string().alphanum().min(<span class="hljs-number">3</span>).required(),<br>    age: Joi.number().integer().min(<span class="hljs-number">1</span>).max(<span class="hljs-number">100</span>).required(),<br>  &#125;,<br>  <span class="hljs-comment">// 2.3 校验 req.params 中的数据</span><br>  params: &#123;<br>    id: Joi.number().integer().min(<span class="hljs-number">0</span>).required(),<br>  &#125;,<br>&#125;<br> <br><span class="hljs-comment">// 3. 在路由中通过 expressJoi(userSchema) 的方式</span><br><span class="hljs-comment">//    调用中间件进行参数验证</span><br>app.post(<span class="hljs-string">&#x27;/adduser/:id&#x27;</span>, expressJoi(userSchema), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> body = req.body<br>  res.send(body)<br>&#125;)<br> <br><span class="hljs-comment">// 4.1 错误级别中间件</span><br>app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, req, res, next</span>) </span>&#123;<br>  <span class="hljs-comment">// 4.1 Joi 参数校验失败</span><br>  <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> Joi.ValidationError) &#123;<br>    <span class="hljs-keyword">return</span> res.send(&#123;<br>      status: <span class="hljs-number">1</span>,<br>      message: err.message,<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 4.2 未知错误</span><br>  res.send(&#123;<br>    status: <span class="hljs-number">1</span>,<br>    message: err.message,<br>  &#125;)<br>&#125;)<br> <br><span class="hljs-comment">// 调用 app.listen 方法，指定端口号并启动web服务器</span><br>app.listen(<span class="hljs-number">3001</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1:3001&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>官网文档</p><p><a href="https://www.npmjs.com/package/@escook/express-joi">@escook/express-joi</a></p></li></ul><h3 id="10-express-session-包"><a href="#10-express-session-包" class="headerlink" title="10. express-session 包"></a>10. <code>express-session</code> 包</h3><ul><li><p>作用</p><p>提供 <code>session</code> 身份认证方案的第三方包,  生成的 <code>session</code> 数据并不保存在客户端,  而是在服务端存储 (默认位置是内存里), 客户端分发的 <code>cookie</code> 仅仅是用来访问 <code>session</code> 数据的 <code>sessionID</code>.</p></li><li><p>安装</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i express-session<br></code></pre></td></tr></table></figure><ul><li>使用方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> app = express()<br><br><span class="hljs-comment">// 创建一个 session 中间件, 并注册到全局</span><br>app.use(session(&#123;<br>  secret: <span class="hljs-string">&#x27;keyboard cat&#x27;</span>,<br>  resave: <span class="hljs-literal">false</span>,<br>  saveUninitialized: <span class="hljs-literal">true</span><br>&#125;))<br><br><span class="hljs-comment">// 通过 req.session 可以存储和获取 session 数据</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (req.session.isLogin) &#123;<br>    res.send(req.session.user)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    res.send(<span class="hljs-string">&#x27;请重新登录!&#x27;</span>)<br>  &#125;<br>&#125;)<br><br>app.post(<span class="hljs-string">&#x27;/logout&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// TODO_04：清空 Session 信息</span><br>  <span class="hljs-comment">// 销毁当前用户存储的 session 数据</span><br>  req.session.destroy()<br>&#125;)<br><br></code></pre></td></tr></table></figure><ul><li><p>官方文档</p><p><a href="https://www.npmjs.com/package/express-session">express-session</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL命令</title>
    <link href="/2021/02/25/mysql/"/>
    <url>/2021/02/25/mysql/</url>
    
    <content type="html"><![CDATA[<h2 id="MYSQL命令"><a href="#MYSQL命令" class="headerlink" title="MYSQL命令"></a>MYSQL命令</h2><h4 id="新建用户："><a href="#新建用户：" class="headerlink" title="新建用户："></a>新建用户：</h4><h4 id="CREATE-USER-name-IDENTIFIED-BY-‘ssapdrow’"><a href="#CREATE-USER-name-IDENTIFIED-BY-‘ssapdrow’" class="headerlink" title="CREATE USER name IDENTIFIED BY ‘ssapdrow’;"></a>CREATE USER name IDENTIFIED BY ‘ssapdrow’;</h4><p>2、更改密码：</p><p>SET PASSWORD FOR name=PASSWORD(‘fdddfd’);</p><p>3、权限管理</p><p>SHOW GRANTS FOR name;   //查看name用户权限</p><p>GRANT SELECT ON db_name.* TO name;　　　　//给name用户db_name数据库的所有权限</p><p>REVOKE SELECT ON db_name.* TO name;　　　　//GRANT的反操作，去除权限；</p><h4 id="数据库操作："><a href="#数据库操作：" class="headerlink" title="数据库操作："></a>数据库操作：</h4><p>1、查看数据库：</p><p>SHOW DATABASES;</p><p>2、创建数据库：</p><p>CREATE DATABASE db_name;　　//db_name为数据库名</p><p>3、使用数据库：</p><p>USE db_name;</p><p>4、删除数据库：</p><p>DROP DATABASE db_name;</p><h4 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h4><p>1、创建表：</p><p>CREATE TABLE table_name(</p><p>id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT,　　　　</p><p>name VARCHAR(60) NOT NULL</p><p>score TINYINT UNSIGNED NOT NULL DEFAULT 0,　　　　//设置默认列值</p><p>PRIMARY KEY(id)</p><p>)ENGINE=InnoDB　　　　//设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索</p><p>DEFAULT charset=utf8;　　//设置默认的编码，防止数据库中文乱码</p><p>如果有条件的创建数据表还可以使用  &gt;CREATE TABLE IF NOT EXISTS tb_name(……..</p><p>2、复制表：</p><p>CREATE TABLE tb_name2 SELECT * FROM tb_name;</p><p>或者部分复制：</p><p>CREATE TABLE tb_name2 SELECT id,name FROM tb_name;</p><p>3、创建临时表：</p><p>CREATE TEMPORARY TABLE tb_name(这里和创建普通表一样);</p><p>4、查看数据库中可用的表：</p><p>SHOW TABLES;</p><p>5、查看表的结构：</p><p>DESCRIBE tb_name;</p><p>也可以使用：</p><p>SHOW COLUMNS in tb_name; 　　　//from也可以</p><p>6、删除表：</p><p>DROP [ TEMPORARY ] TABLE [ IF EXISTS ] tb_name[ ,tb_name2…….];</p><p>实例：</p><p>DROP TABLE IF EXISTS tb_name;</p><p>7、表重命名：</p><p>RENAME TABLE name_old TO name_new;</p><p>还可以使用：</p><p>ALTER TABLE name_old RENAME name_new;</p><h4 id="修改表："><a href="#修改表：" class="headerlink" title="修改表："></a>修改表：</h4><p>1、更改表结构：</p><p>ALTER TABLE tb_name ADD[CHANGE,RENAME,DROP] …要更改的内容</p><p>ALTER TABLE tb_name ADD COLUMN address varchar(80) NOT NU</p><p>ALTER TABLE tb_name DROP addre</p><p>ALTER TABLE tb_name CHANGE score score SMALLINT(4) NOT NULL;</p><h4 id="插入数据："><a href="#插入数据：" class="headerlink" title="插入数据："></a>插入数据：</h4><p>1、插入数据：</p><p>INSERT INTO tb_name(id,name,score)VALUES(NULL,’张三’,140),(NULL,’张四’,178),(NULL,’张五’,134);</p><p>这里的插入多条数据直接在后边加上逗号，直接写入插入的数据即可；主键id是自增的列，可以不用写。</p><p>2、插入检索出来的数据：</p><p>INSERT INTO tb_name(name,score) SELECT name,score FROM tb_name2;</p><h4 id="更新数据："><a href="#更新数据：" class="headerlink" title="更新数据："></a>更新数据：</h4><p>1、指定更新数据：</p><p>UPDATE tb_name SET score=189 WHERE id=2;</p><p>UPDATE tablename SET columnName=NewValue [ WHERE condition ]</p><h4 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h4><p>1、删除数据：</p><p>DELETE FROM tb_name WHERE id=3;</p><h4 id="条件控制："><a href="#条件控制：" class="headerlink" title="条件控制："></a>条件控制：</h4><p>1、WHERE 语句：</p><p>SELECT * FROM tb_name WHERE id=3;</p><p>2、HAVING 语句：</p><p>SELECT * FROM tb_name GROUP BY score HAVING count(*)&gt;2</p><p>3、相关条件控制符：<br>AND 、OR</p><p>　</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模块的加载机制</title>
    <link href="/2021/02/21/module/"/>
    <url>/2021/02/21/module/</url>
    
    <content type="html"><![CDATA[<h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><h4 id="一-模块加载机制"><a href="#一-模块加载机制" class="headerlink" title="一.模块加载机制"></a>一.模块加载机制</h4><p> 一、模块优先从缓存中进行加载 </p><p>   模块在第一次加载后会被缓存, 如果每次调用 require(‘foo’) 都解析到同一文件，则返回相同的对象,</p><p>  不会导致模块的代码被执行多次</p><p>二、缓存的作用</p><p>   不论是 node.js 内置的核心模块，用户自定义的模块还是第三方模块，都有对应的缓存策略，提升模块的</p><p>  加载效率</p><p>说明：文档地址（<a href="http://nodejs.cn/api/modules.html#modules_caching%EF%BC%89">http://nodejs.cn/api/modules.html#modules_caching）</a></p><h4 id="二-内置模块加载机制"><a href="#二-内置模块加载机制" class="headerlink" title="二.内置模块加载机制"></a>二.内置模块加载机制</h4><p>require() 总是会优先加载核心模块, 比如 require(‘http’) 始终返回内置的 HTTP 模块，即使有同名文件</p><h4 id="三-自定义模块加载机制"><a href="#三-自定义模块加载机制" class="headerlink" title="三.自定义模块加载机制"></a>三.自定义模块加载机制</h4><p> 一、自定义模块的加载机制 </p><p>   使用 require() 方法去加载自定义模块，必须指定 ‘/‘、 ‘./‘ 或 ‘../‘ 开头的路径，如果没有这个</p><p>  路径标识，node 会默认把它当作是一个核心模块或来自 node_modules 目录下的第三方模块</p><p>二、自定义文件模块</p><p>   如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 .js、 .json 或 .node 拓展名再加载</p><p>三、自定义目录模块</p><p>   当传递一个目录标识符给 require () 方法时, 加载的顺序如下:</p><ol><li><p>在加载的目录下查找 package.json 的文件, 并寻找 main 属性作为 require 的入口</p></li><li><p>上述找不到, Node.js 将会试图加载目录下的 index.js 或 index.node 文件</p></li></ol><h4 id="四-第三方模块加载机制"><a href="#四-第三方模块加载机制" class="headerlink" title="四.第三方模块加载机制"></a>四.第三方模块加载机制</h4><p> 如果传递给 require() 的模块标识符不是一个核心模块，也没有以 ‘/‘ 、 ‘../‘ 或 ‘./‘ 开头，</p><p>  那么 Node.js 会从当前模块的父目录开始，尝试从它的 /node_modules 目录里加载模块。如果还是没有找到，</p><p>  则移动到再上一层父目录，直到文件系统的根目录。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>npm命令</title>
    <link href="/2021/02/21/npm/"/>
    <url>/2021/02/21/npm/</url>
    
    <content type="html"><![CDATA[<h2 id="npm命令"><a href="#npm命令" class="headerlink" title="npm命令"></a>npm命令</h2><h4 id="一-包管理命令"><a href="#一-包管理命令" class="headerlink" title="一.包管理命令"></a>一.包管理命令</h4><p> 1、下载一个指定的包 </p><p>   <code>npm i 包的具体名称</code> </p><p>2、查看一个指定包</p><p>   <code>npm view 包的具体名称</code></p><p>3、下载指定版本的包</p><p>   <code>npm i 包的具体名称@版本号</code></p><h4 id="二-快速创建包管理配置文件"><a href="#二-快速创建包管理配置文件" class="headerlink" title="二.快速创建包管理配置文件"></a>二.快速创建包管理配置文件</h4><p>在项目的根目录下执行 <code>npm init -y</code> 命令</p><h4 id="三-卸载指定的包"><a href="#三-卸载指定的包" class="headerlink" title="三.卸载指定的包"></a>三.卸载指定的包</h4><p><code>npm uninstall 包名称</code></p><h4 id="四-全局安装包"><a href="#四-全局安装包" class="headerlink" title="四.全局安装包"></a>四.全局安装包</h4><p><code>npm install -g 包名称@版本号</code></p><h4 id="五-发布包"><a href="#五-发布包" class="headerlink" title="五.发布包"></a>五.发布包</h4><p>1.在包的发布目录下执行登录命令</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> login<br></code></pre></td></tr></table></figure><ol start="2"><li><p>在包的发布目录下面执行命令</p><p><code>npm publish</code></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2021/02/04/ajax/"/>
    <url>/2021/02/04/ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>能够知道和服务器相关的基本概念</li><li>能够知道客户端和服务器通信的过程</li><li>能够知道数据也是一种资源</li><li>能够说出什么是<code>Ajax</code>以及应用场景</li><li>能够使用<code>jQuery</code>中的<code>Ajax</code>函数请求数据</li><li>能够知道接口和接口文档的概念</li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="客户端与服务器（⭐⭐⭐）"><a href="#客户端与服务器（⭐⭐⭐）" class="headerlink" title="客户端与服务器（⭐⭐⭐）"></a>客户端与服务器（⭐⭐⭐）</h2><h3 id="上网的目的"><a href="#上网的目的" class="headerlink" title="上网的目的"></a>上网的目的</h3><p><img src="images/%E4%B8%8A%E7%BD%91%E7%9B%AE%E7%9A%84.png"></p><p>上网的<strong>本质目的：</strong>通过互联网的形式来 <strong>获取和消费资源</strong></p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>上网过程中，负责 <strong>存放和对外提供资源</strong> 的电脑，叫做服务器</p><p><img src="images/%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在上网过程中，负责 <strong>获取和消费资源</strong> 的电脑，叫做客户端</p><p><img src="images/%E5%AE%A2%E6%88%B7%E7%AB%AF.png"></p><h2 id="URL地址的概念-amp-组成"><a href="#URL地址的概念-amp-组成" class="headerlink" title="URL地址的概念&amp;组成"></a>URL地址的概念&amp;组成</h2><h3 id="URL的概念"><a href="#URL的概念" class="headerlink" title="URL的概念"></a>URL的概念</h3><p>URL（全称是 <code>UniformResourceLocator</code>） 中文叫 <strong>统一资源定位符</strong>，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源</p><h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>URL地址一般由三部分组成:</p><ul><li>客户端与服务器之间的 <strong>通信协议</strong></li><li>存有该资源的 <strong>服务器名称</strong></li><li>资源在服务器上 <strong>具体的存放位置</strong></li></ul><p><img src="images/URL%E7%BB%84%E6%88%90.png"></p><h2 id="客户端与服务器通讯过程（⭐⭐⭐）"><a href="#客户端与服务器通讯过程（⭐⭐⭐）" class="headerlink" title="客户端与服务器通讯过程（⭐⭐⭐）"></a>客户端与服务器通讯过程（⭐⭐⭐）</h2><p><img src="images/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png"></p><p><strong>注意：</strong></p><ul><li>客户端与服务器之间的通讯过程，分为： <strong>请求-处理-响应</strong> 三个步骤</li><li>网页中每一个资源，都是通过 <strong>请求-处理-响应</strong> 的方式从服务器获取回来的</li></ul><h2 id="基于浏览器工具分析通讯过程"><a href="#基于浏览器工具分析通讯过程" class="headerlink" title="基于浏览器工具分析通讯过程"></a>基于浏览器工具分析通讯过程</h2><p><img src="images/%E5%B7%A5%E5%85%B7%E6%9D%A5%E5%88%86%E6%9E%90%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png"></p><p><strong>步骤：</strong></p><ul><li>打开<code>Chorme</code>浏览器</li><li><code>Ctrl + Shift + I（F12）</code> 打开 Chrome 的开发者工具</li><li>切换到 <code>Network</code> 面板</li><li>选中<code>Doc</code> 页签</li><li>刷新页面，分析客户端与服务器的通讯过程</li></ul><h2 id="服务器对外提供的资源"><a href="#服务器对外提供的资源" class="headerlink" title="服务器对外提供的资源"></a>服务器对外提供的资源</h2><h3 id="常见资源"><a href="#常见资源" class="headerlink" title="常见资源"></a>常见资源</h3><p><img src="images/%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%9A%84%E8%B5%84%E6%BA%90.png"></p><h3 id="数据也是资源（⭐⭐⭐）"><a href="#数据也是资源（⭐⭐⭐）" class="headerlink" title="数据也是资源（⭐⭐⭐）"></a>数据也是资源（⭐⭐⭐）</h3><p><strong>网页中的数据，也是服务器对外提供的一种资源</strong>，例如股票数据，各行业排行榜等</p><h2 id="网页中如何请求数据"><a href="#网页中如何请求数据" class="headerlink" title="网页中如何请求数据"></a>网页中如何请求数据</h2><blockquote><p>数据，也是服务器对外提供的一种 资源，只要是资源，必然要通过 请求 - 处理 - 响应 的方式进行获取</p></blockquote><p><img src="images/%E5%A6%82%E4%BD%95%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE.png"></p><p>如果要在网页中请求服务器上的数据资源，需要用到 <code>XMLHttpRequest</code> 对象</p><p><code>XMLHttpRequest</code>（简称 <code>xhr</code>）是浏览器提供的<code>JS</code>成员，通过它，可以请求服务器上的数据资源</p><p>最简单的用法 <code>var xhrObj = new XMLHttpRequest()</code></p><h2 id="资源的请求方式（⭐⭐⭐）"><a href="#资源的请求方式（⭐⭐⭐）" class="headerlink" title="资源的请求方式（⭐⭐⭐）"></a>资源的请求方式（⭐⭐⭐）</h2><p>客户端请求服务器时，请求的方式 <strong>有很多种</strong>，最常见的两种请求方式分别是 <code>get</code> 和 <code>post</code> 请求</p><ul><li><p><code>get 请求</code>，通常用于 <strong>获取服务器资源</strong>（要资源）</p><p>例如：根据 <code>URL</code> 地址，从服务器获取 <code>HTML</code>文件、<code>css</code>文件、<code>js</code>文件、图片文件、数据资源等</p></li><li><p><code>post 请求</code>，通常用于 <strong>向服务器提交数据</strong>（送资源）</p><p>例如：登录时，向服务器 <strong>提交登录信息</strong>、注册时向服务器 <strong>提交注册信息</strong>、添加用户时向服务器 <strong>提交用户信息</strong>等各种 <strong>数据提交操作</strong></p></li></ul><h1 id="了解Ajax"><a href="#了解Ajax" class="headerlink" title="了解Ajax"></a>了解<code>Ajax</code></h1><h2 id="什么是Ajax（⭐⭐⭐）"><a href="#什么是Ajax（⭐⭐⭐）" class="headerlink" title="什么是Ajax（⭐⭐⭐）"></a>什么是<code>Ajax</code>（⭐⭐⭐）</h2><p><code>Ajax</code> 的全称是 <code>Asynchronous JavaScript And XML</code>（异步 <code>JavaScript</code> 和 <code>xml</code>）</p><p>通俗理解：在网页中利用 <code>XMLHttpRequest</code> 对象和服务器进行数据交互的方式，就是<code>Ajax</code></p><h2 id="为什么要学Ajax"><a href="#为什么要学Ajax" class="headerlink" title="为什么要学Ajax"></a>为什么要学<code>Ajax</code></h2><p>之前所学的技术，只能把网页做的更美观漂亮，或添加一些动画效果，但还是，<code>Ajax</code>能让我们轻松实现 <strong>网页</strong> 与 <strong>服务器</strong>之间的 <strong>数据交互</strong></p><p><img src="images/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0ajax.png"></p><h2 id="Ajax应该用场景（⭐⭐⭐）"><a href="#Ajax应该用场景（⭐⭐⭐）" class="headerlink" title="Ajax应该用场景（⭐⭐⭐）"></a><code>Ajax</code>应该用场景（⭐⭐⭐）</h2><h4 id="场景一：用户名检测"><a href="#场景一：用户名检测" class="headerlink" title="场景一：用户名检测"></a>场景一：用户名检测</h4><p>注册用户时，通过 <code>ajax</code> 的形式，动态 <strong>检测用户名是否被占用</strong></p><p><img src="images/ajax%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png"></p><h4 id="场景二：搜索提示"><a href="#场景二：搜索提示" class="headerlink" title="场景二：搜索提示"></a>场景二：搜索提示</h4><p>当输入搜索关键字时，通过 <code>ajax</code> 的形式，动态 <strong>加载搜索提示列表</strong></p><p><img src="images/ajax%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-02.png"></p><h4 id="场景三：数据分页显示"><a href="#场景三：数据分页显示" class="headerlink" title="场景三：数据分页显示"></a>场景三：数据分页显示</h4><p>当点击页码值得时候，通过 <code>ajax</code> 的形式，<strong>根据页码值动态刷新表格的数据</strong></p><p><img src="images/ajax%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-03.png"></p><h4 id="场景四：数据的增删改查"><a href="#场景四：数据的增删改查" class="headerlink" title="场景四：数据的增删改查"></a>场景四：数据的增删改查</h4><p>数据的添加、删除、修改、查询操作，都需要通过 <code>ajax</code> 的形式，来实现数据的交互<br><img src="images/ajax%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-04.png"></p><h1 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a><code>jQuery</code>中的Ajax</h1><p>浏览器中提供的 <code>XMLHttpRequest</code> 用法比较复杂，所以 <code>jQuery</code> 对 <code>XMLHttpRequest</code> 进行了封装，提供了一系列Ajax相关的函数，极大地 <strong>降低了Ajax的使用难度</strong></p><p><code>jQuery</code>中发起 Ajax 请求最常用的三个方法如下：</p><ul><li><code>$.get()</code> get方式请求，用于获取数据</li><li><code>$.post()</code> post方式请求，用于提交数据</li><li><code>$.ajax()</code> 比较综合，既可以获取数据，又可以提交数据</li></ul><h2 id="get-函数介绍（⭐⭐）"><a href="#get-函数介绍（⭐⭐）" class="headerlink" title="$.get() 函数介绍（⭐⭐）"></a>$.get() 函数介绍（⭐⭐）</h2><p><code>jQuery</code> 中 <code>$.get()</code> 函数的功能单一，专门用来发起 <code>get</code> 请求，从而将服务器上的资源请求到客户端来进行使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.get(url,[data],[callback])<br></code></pre></td></tr></table></figure><p><img src="images/get%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0.png"></p><h3 id="get-发起不带参数的请求"><a href="#get-发起不带参数的请求" class="headerlink" title="$.get()发起不带参数的请求"></a>$.get()发起不带参数的请求</h3><p>使用 $.get() 函数 发起不带参数的请求时，直接提供给 <strong>请求的 URL 地址</strong> 和 <strong>请求成功之后的回调函数</strong> 即可，示例代码如下</p><p><img src="images/get%E8%AF%B7%E6%B1%82%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0.png"></p><h3 id="get-发起携带参数的请求"><a href="#get-发起携带参数的请求" class="headerlink" title="$.get()发起携带参数的请求"></a>$.get()发起携带参数的请求</h3><p>使用<code>$.get()</code> 发起携带参数的请求，那么携带的参数应该写在第二个参数的位置，示例代码如下：</p><p><img src="images/get%E8%AF%B7%E6%B1%82%E6%90%BA%E5%B8%A6%E5%8F%82%E6%95%B0.png"></p><h2 id="post-函数介绍（⭐⭐）"><a href="#post-函数介绍（⭐⭐）" class="headerlink" title="$.post() 函数介绍（⭐⭐）"></a>$.post() 函数介绍（⭐⭐）</h2><p><code>jQuery</code> 中 <code>$.post()</code> 函数的功能单一，专门用来发起<code>post</code>请求，从而向服务器提交数据</p><p><code>$.post()</code> 函数的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.post(url,[data],[callback])<br></code></pre></td></tr></table></figure><p>参数各自代表的含义如下：</p><p><img src="images/post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0.png"></p><h3 id="post-向服务器提交数据"><a href="#post-向服务器提交数据" class="headerlink" title="$.post() 向服务器提交数据"></a>$.post() 向服务器提交数据</h3><p>使用 <code>$.post()</code> 向服务器提交数据的示例代码如下：</p><p><img src="images/post%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE.png"></p><h2 id="ajax-函数介绍（⭐⭐⭐）"><a href="#ajax-函数介绍（⭐⭐⭐）" class="headerlink" title="$.ajax() 函数介绍（⭐⭐⭐）"></a><code>$.ajax()</code> 函数介绍（⭐⭐⭐）</h2><p>相比于 <code>$.get()</code> 和 <code>$.post()</code> 函数，<code>jQuery</code> 中提供的 <code>$.ajax()</code> 函数，是一个功能比较综合的函数，它允许我们对 <code>Ajax</code> 请求进行更详细的配置。</p><p><code>$.ajax()</code> 函数的基本语法如下：</p><p><img src="images/ajax%E8%AF%AD%E6%B3%95%E5%8F%82%E6%95%B0.png"></p><h3 id="ajax-发起-get-请求"><a href="#ajax-发起-get-请求" class="headerlink" title="$.ajax() 发起 get 请求"></a><code>$.ajax()</code> 发起 get 请求</h3><p>使用 <code>$.ajax()</code> 发起 <code>GET</code> 请求时，只需要将 <code>type</code> 属性 的值设置为 ‘<code>GET</code>’ 即可：</p><p><img src="images/ajax%E5%8F%91%E8%B5%B7get%E8%AF%B7%E6%B1%82.png"></p><h3 id="ajax-发起-post-请求"><a href="#ajax-发起-post-请求" class="headerlink" title="$.ajax 发起 post 请求"></a><code>$.ajax</code> 发起 post 请求</h3><p>使用 <code>$.ajax()</code> 发起 <code>post</code>请求，只需要把 <code>type</code>属性的值 设置为 ‘<code>post</code>’ 即可</p><p><img src="images/ajax%E5%8F%91%E8%B5%B7post%E8%AF%B7%E6%B1%82.png"></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口的概念（⭐⭐⭐）"><a href="#接口的概念（⭐⭐⭐）" class="headerlink" title="接口的概念（⭐⭐⭐）"></a>接口的概念（⭐⭐⭐）</h2><p>使用 <code>Ajax</code> 请求数据时，被请求的 <code>URL</code> 地址，就叫做 数据接口（简称<strong>接口</strong>）。同时，每个接口必须有请求方式。</p><p>例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.liulongbin.top:<span class="hljs-number">3006</span><span class="hljs-regexp">/api/g</span>etbooks 获取图书列表的接口（get请求）<br>http:<span class="hljs-regexp">//</span>www.liulongbin.top:<span class="hljs-number">3006</span><span class="hljs-regexp">/api/</span>addbook  添加图书的接口（post请求）<br></code></pre></td></tr></table></figure><h2 id="接口的请求过程"><a href="#接口的请求过程" class="headerlink" title="接口的请求过程"></a>接口的请求过程</h2><h3 id="GET方式请求接口的过程"><a href="#GET方式请求接口的过程" class="headerlink" title="GET方式请求接口的过程"></a>GET方式请求接口的过程</h3><p><img src="images/get%E6%96%B9%E5%BC%8F%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E8%BF%87%E7%A8%8B.png"></p><h3 id="POST方式请求接口的过程"><a href="#POST方式请求接口的过程" class="headerlink" title="POST方式请求接口的过程"></a>POST方式请求接口的过程</h3><p><img src="images/post%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E8%BF%87%E7%A8%8B.png"></p><h2 id="接口测试工具"><a href="#接口测试工具" class="headerlink" title="接口测试工具"></a>接口测试工具</h2><h3 id="什么是接口测试工具"><a href="#什么是接口测试工具" class="headerlink" title="什么是接口测试工具"></a>什么是接口测试工具</h3><p>为了验证接口是否被正常被访问，我们常常需要使用接口测试工具，来对数据接口进行检测</p><p><strong>好处：</strong>接口测试工具能让我们在 <strong>不写任何代码</strong> 的情况下，对接口进行 <strong>调用</strong> 和 <strong>测试</strong></p><p>常用的就是：<a href="https://www.getpostman.com/downloads/">PostMan</a></p><p><img src="images/postMan.png"></p><h3 id="了解-Postman-界面结构"><a href="#了解-Postman-界面结构" class="headerlink" title="了解 Postman 界面结构"></a>了解 Postman 界面结构</h3><p><img src="images/Postman%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D.png"></p><h3 id="使用PostMan测试GET接口"><a href="#使用PostMan测试GET接口" class="headerlink" title="使用PostMan测试GET接口"></a>使用<code>PostMan</code>测试GET接口</h3><p><img src="images/Postman%E6%B5%8B%E8%AF%95get%E8%AF%B7%E6%B1%82.png"></p><h3 id="使用PostMan测试POST接口"><a href="#使用PostMan测试POST接口" class="headerlink" title="使用PostMan测试POST接口"></a>使用<code>PostMan</code>测试POST接口</h3><p><img src="images/Postman%E6%B5%8B%E8%AF%95post%E8%AF%B7%E6%B1%82.png"></p><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><h3 id="什么是接口文档（⭐⭐⭐）"><a href="#什么是接口文档（⭐⭐⭐）" class="headerlink" title="什么是接口文档（⭐⭐⭐）"></a>什么是接口文档（⭐⭐⭐）</h3><p>接口文档，顾名思义就是 <strong>接口的说明文档</strong>，<strong>它是我们调用接口的依据</strong>。好的接口文档包含了对 <strong>接口URL</strong>，<strong>参数</strong> 以及 <strong>输出内容</strong> 的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用</p><h3 id="接口文档的组成部分"><a href="#接口文档的组成部分" class="headerlink" title="接口文档的组成部分"></a>接口文档的组成部分</h3><p>接口文档可以包含很多信息，也可以按需进行精简，不过，一个合格的接口文档，应该包含以下6项内容，从而为接口的调用提供依据：</p><ul><li><strong>接口名称：</strong>用来标识各个接口的简单说明，如 <strong>登录接口</strong>，<strong>获取图书列表接口</strong>等</li><li><strong>接口URL：</strong>接口的调用地址</li><li><strong>调用方式：</strong>接口的调用方式，如 <strong>GET</strong> 或者 <strong>POST</strong></li><li><strong>参数格式：</strong>接口需要传递的参数，每个参数必须包含 <strong>参数名称</strong>、<strong>参数类型</strong>、<strong>是否必选</strong>、<strong>参数说明</strong> 这4项内容</li><li><strong>响应格式：</strong>接口的返回值的详细描述，一般包含<strong>数据名称</strong>、<strong>数据类型</strong>、<strong>说明</strong>3项内容</li><li><strong>返回示例（可选）：</strong>通过对象的形式，列举服务器返回数据的结构</li></ul><h3 id="接口文档示例"><a href="#接口文档示例" class="headerlink" title="接口文档示例"></a>接口文档示例</h3><p><img src="images/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%AF%B7%E6%B1%82%E7%A4%BA%E4%BE%8B.png"></p><p><img src="images/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%93%8D%E5%BA%94%E7%A4%BA%E4%BE%8B.png"></p><p><img src="images/%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E8%BF%94%E5%9B%9E%E7%A4%BA%E4%BE%8B.png"></p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="图书管理"><a href="#图书管理" class="headerlink" title="图书管理"></a>图书管理</h2><h3 id="项目效果"><a href="#项目效果" class="headerlink" title="项目效果"></a>项目效果</h3><p><img src="images/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p><h3 id="UI界面搭建"><a href="#UI界面搭建" class="headerlink" title="UI界面搭建"></a><code>UI</code>界面搭建</h3><p><strong>需要使用到的库和插件</strong></p><ul><li>用到的 <code>css</code> 库 <code>bootstrap.css</code></li><li>用到的 <code>javascript</code> 库 <code>jquery.js</code></li><li>用到 <code>vs code</code> 插件 <code>Bootstrap 3 Snippets</code></li></ul><p><strong>搭建步骤</strong></p><ul><li>Panel面板搭建<ul><li>创建panel板 （快捷键：<code>bs3-panel:primary</code>）</li><li>在 <code>panel-body</code> 里面，创建3个对应的输入框 （快捷键：<code>bs3-input:addon:text</code>），对应修改标题</li><li>在 <code>panel-body</code> 最后面，创建 <code>button</code>按钮 （快捷键：<code>bs3-button:primary</code>）,修改内容</li></ul></li><li>图书的表格<ul><li>创建 table（快捷键：<code>bs3-table:bordered</code>）</li><li>在里面创建对应5个<code>td</code>，填写里面内容</li></ul></li></ul><h3 id="获取图书列表数据"><a href="#获取图书列表数据" class="headerlink" title="获取图书列表数据"></a>获取图书列表数据</h3><p><strong>步骤：</strong></p><ul><li>查阅资料中的接口文档，找到获取图书列表的接口</li><li>定义 script 标签，创建入口函数</li><li>利用 $.get() 方法，传入相应的<code>url</code>，和成功之后的回调函数</li><li>在回调函数中获取到请求成功的数据</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取图书列表数据</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBookList</span>(<span class="hljs-params"></span>) </span>&#123;<br>   $.get(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>         <span class="hljs-built_in">console</span>.log(res)<br>   &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="渲染图书列表"><a href="#渲染图书列表" class="headerlink" title="渲染图书列表"></a>渲染图书列表</h3><p><strong>步骤：</strong></p><ul><li>根据返回状态码来判断是否成功请求到数据</li><li>创建数组，用来存放<strong>行</strong>数据（<code>rows</code>）</li><li>遍历服务器返回的数组，每遍历一次，利用数组（<code>rows</code>）去<code>push</code>  <code>&lt;tr&gt;&lt;/tr&gt;</code></li><li>每一行 <code>tr</code> 里面包含了5个<code>td</code></li><li>给每一个 <code>td</code> 设置对应内容即可</li><li>遍历循环完毕之后，找到内容容器，先清空当前内容（以免有重复数据），然后添加 <code>rows</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rows = []<br>$.each(res.data, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, item</span>) </span>&#123;<br>     rows.push(<span class="hljs-string">&#x27;&lt;tr&gt;&lt;td&gt;&#x27;</span> + item.id + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span> + item.bookname + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span> + item.author + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&#x27;</span> + item.publisher + <span class="hljs-string">&#x27;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;del&quot; data-id=&quot;&#x27;</span> + item.id + <span class="hljs-string">&#x27;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&#x27;</span>)<br>&#125;)<br>$(<span class="hljs-string">&#x27;#tb&#x27;</span>).empty().append(rows.join(<span class="hljs-string">&#x27;&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="删除功能实现"><a href="#删除功能实现" class="headerlink" title="删除功能实现"></a>删除功能实现</h3><h4 id="删除链接绑定单击事件处理函数"><a href="#删除链接绑定单击事件处理函数" class="headerlink" title="删除链接绑定单击事件处理函数"></a>删除链接绑定单击事件处理函数</h4><ul><li>利用 <code>tbody</code> 容器，通过<strong>事件委派</strong>的方式，给动态创建的<code>a</code>标签绑定事件</li><li>删除图书需要通过<code>id</code>删除，所以我们需要得到对应的<code>id</code>，我们利用自定义属性的方式，传递过来相应的<code>id</code></li></ul><h4 id="删除功能实现-1"><a href="#删除功能实现-1" class="headerlink" title="删除功能实现"></a>删除功能实现</h4><ul><li>查阅<strong>删除</strong>的接口文档</li><li>在a标签点击事件处理函数里面利用<code>$.get()</code>方法，请求服务器，传入要删除的对应<code>id</code></li><li>删除成功之后，调用 <code>getBookList()</code> 刷新页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;tbody&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;.del&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> id = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;data-id&#x27;</span>)<br>  $.get(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/delbook&#x27;</span>, &#123;<br>    id: id<br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (res.status !== <span class="hljs-number">200</span>) <span class="hljs-keyword">return</span> alert(<span class="hljs-string">&#x27;删除图书失败！&#x27;</span>)<br>    getBookList()<br>   &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="添加功能实现"><a href="#添加功能实现" class="headerlink" title="添加功能实现"></a>添加功能实现</h3><h4 id="添加按钮绑定点击事件"><a href="#添加按钮绑定点击事件" class="headerlink" title="添加按钮绑定点击事件"></a>添加按钮绑定点击事件</h4><ul><li>获取三个输入框的内容</li><li>判断三个输入框是否输入了内容，如果没有进行提示</li></ul><h4 id="实现图书添加功能"><a href="#实现图书添加功能" class="headerlink" title="实现图书添加功能"></a>实现图书添加功能</h4><ul><li>查阅接口文档</li><li>注意接口文档需要提交的参数名，我们需要保持一致</li><li>调用<code>$.post()</code> 方法，传入请求路径，然后组拼需要提交的参数</li><li>在成功回调里面判断返回值是否是201，如果是201代表成功，反之没有成功，进行提示</li><li>请求成功之后，调用<code>gettBookList()</code> 方法刷新页面，同时把输入框里面值清空</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;#btnAdd&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">var</span> bookname = $(<span class="hljs-string">&#x27;#iptBookname&#x27;</span>).val().trim()<br>     <span class="hljs-keyword">var</span> author = $(<span class="hljs-string">&#x27;#iptAuthor&#x27;</span>).val().trim()<br>     <span class="hljs-keyword">var</span> publisher = $(<span class="hljs-string">&#x27;#iptPublisher&#x27;</span>).val().trim()<br>     <span class="hljs-keyword">if</span> (bookname.length &lt;= <span class="hljs-number">0</span> || author.length &lt;= <span class="hljs-number">0</span> || publisher.length &lt;= <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">return</span> alert(<span class="hljs-string">&#x27;请填写完整的图书信息！&#x27;</span>)<br>     &#125;<br><br>     $.post(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>, &#123;<br>         bookname: bookname,<br>         author: author,<br>         publisher: publisher<br>     &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;<br>         <span class="hljs-keyword">if</span> (res.status !== <span class="hljs-number">201</span>) <span class="hljs-keyword">return</span> alert(<span class="hljs-string">&#x27;添加图书失败！&#x27;</span>)<br>         getBookList()<br>         $(<span class="hljs-string">&#x27;#iptBookname&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>)<br>         $(<span class="hljs-string">&#x27;#iptAuthor&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>)<br>         $(<span class="hljs-string">&#x27;#iptPublisher&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>)<br>     &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="聊天机器人"><a href="#聊天机器人" class="headerlink" title="聊天机器人"></a>聊天机器人</h2><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="images/%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C.png"></p><h3 id="实现功能点"><a href="#实现功能点" class="headerlink" title="实现功能点"></a>实现功能点</h3><ul><li>梳理案例代码结构</li><li>将用户输入的内容渲染到聊天窗口</li><li>发起请求获取聊天消息</li><li>将机器人的聊天内容转为语音</li><li>通过 <audio> 播放语音</li><li>使用回车发送消息</li></ul><h3 id="梳理案例的代码结构"><a href="#梳理案例的代码结构" class="headerlink" title="梳理案例的代码结构"></a>梳理案例的代码结构</h3><ul><li><p><code>UI</code>结构梳理</p><p><img src="images/%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BAUI%E7%BB%93%E6%9E%84.png"></p></li><li><p>业务代码抽离</p></li><li><p><code>resetui()</code> 函数作用-让聊天框区域自动滚动到底部</p></li></ul><h3 id="将用户输入的内容渲染到聊天窗口"><a href="#将用户输入的内容渲染到聊天窗口" class="headerlink" title="将用户输入的内容渲染到聊天窗口"></a>将用户输入的内容渲染到聊天窗口</h3><ul><li>为发送按钮绑定点击事件</li><li>在点击事件函数里面判断一下用户输入内容是否为空，注意：如果为空，我们清除一下输入框内容</li><li>获取到对应的<code>ul</code>容器，调用 <code>append</code> 函数来追加 <code>li</code>，注意：追加<code>li</code>的类名叫做 <code>right_word</code></li><li>清除文本输入框的值</li><li>最后调用一下 <code>resetui()</code>，让聊天框区域自动滚动到底部</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 为发送按钮绑定鼠标点击事件</span><br>$(<span class="hljs-string">&#x27;#btnSend&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> text = $(<span class="hljs-string">&#x27;#ipt&#x27;</span>).val().trim()<br>    <span class="hljs-keyword">if</span> (text.length &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> $(<span class="hljs-string">&#x27;#ipt&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 如果用户输入了聊天内容，则将聊天内容追加到页面上显示</span><br>    $(<span class="hljs-string">&#x27;#talk_list&#x27;</span>).append(<span class="hljs-string">&#x27;&lt;li class=&quot;right_word&quot;&gt;&lt;img src=&quot;img/person02.png&quot; /&gt; &lt;span&gt;&#x27;</span> + text + <span class="hljs-string">&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;</span>)<br>    $(<span class="hljs-string">&#x27;#ipt&#x27;</span>).val(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-comment">// 重置滚动条的位置</span><br>    resetui()<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="发起请求获取聊天信息"><a href="#发起请求获取聊天信息" class="headerlink" title="发起请求获取聊天信息"></a>发起请求获取聊天信息</h3><ul><li>定义一个函数 <code>getMsg()</code> 接收一个参数，参数就是用户发送的信息</li><li>利用 <code>$.ajax()</code> 发送一个 GET 方式请求，传入请求地址 <code>http://ajax.frontend.itheima.net:3006/api/robot</code></li><li>定义请求数据 <code>spoken：value</code></li><li>定义<code>success</code>成功的回调，在回调函数里面判断返回数据的 <code>message</code> 是否等于 <code>success</code></li><li>给容器动态添加返回的内容</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取聊天机器人发送回来的消息</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMsg</span>(<span class="hljs-params">text</span>) </span>&#123;<br>   $.ajax(&#123;<br>     method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>     url: <span class="hljs-string">&#x27;http://ajax.frontend.itheima.net:3006/api/robot&#x27;</span>,<br>     data: &#123;<br>       spoken: text<br>     &#125;,<br>     success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>       <span class="hljs-comment">// console.log(res)</span><br>       <span class="hljs-keyword">if</span> (res.message === <span class="hljs-string">&#x27;success&#x27;</span>) &#123;<br>         <span class="hljs-comment">// 接收聊天消息</span><br>         <span class="hljs-keyword">var</span> msg = res.data.info.text<br>         $(<span class="hljs-string">&#x27;#talk_list&#x27;</span>).append(<span class="hljs-string">&#x27;&lt;li class=&quot;left_word&quot;&gt;&lt;img src=&quot;img/person01.png&quot; /&gt; &lt;span&gt;&#x27;</span> + msg + <span class="hljs-string">&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;</span>)<br>         <span class="hljs-comment">// 重置滚动条的位置</span><br>         resetui()<br>       &#125;<br>     &#125;<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="将机器人聊天内容转成语音"><a href="#将机器人聊天内容转成语音" class="headerlink" title="将机器人聊天内容转成语音"></a>将机器人聊天内容转成语音</h3><ul><li>封装函数 <code>getVoice()</code> 接收一个参数，机器人的聊天信息</li><li>利用 <code>$.ajax()</code> 发送一个 GET 方式请求，传入请求地址 <code>http://ajax.frontend.itheima.net:3006/api/synthesize</code></li><li>定义请求数据 <code>text：value</code></li><li>定义<code>success</code>成功的回调，判断返回的状态码是否是200，如果是代表成功</li><li>在页面上定义 <code>audio</code> 标签，设置隐藏，等数据返回之后，利用这个 <code>audio</code> 来进行播放。设置 <code>autoplay</code> 属性来进行自动播放</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 把文字转化为语音进行播放</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVoice</span>(<span class="hljs-params">text</span>) </span>&#123;<br>    $.ajax(&#123;<br>      method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>      url: <span class="hljs-string">&#x27;http://ajax.frontend.itheima.net:3006/api/synthesize&#x27;</span>,<br>      data: &#123;<br>        text: text<br>      &#125;,<br>      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>        <span class="hljs-comment">// console.log(res)</span><br>        <span class="hljs-keyword">if</span> (res.status === <span class="hljs-number">200</span>) &#123;<br>          <span class="hljs-comment">// 播放语音</span><br>          $(<span class="hljs-string">&#x27;#voice&#x27;</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, res.voiceUrl)<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="通过回车键发送消息"><a href="#通过回车键发送消息" class="headerlink" title="通过回车键发送消息"></a>通过回车键发送消息</h3><ul><li>给文本输入框注册 <code>keyup</code> 事件，按键弹起的事件监听</li><li>在事件函数里面，通过<code>keycode</code> 来获取对应的按键的 机器码</li><li>判断 <code>keycode</code> 是否等于 13（不需要去记忆，开发时候打印调试一下就行了），如果是，代表是回车键</li><li>如果是回车键，模拟用户点击：  <code>$(&#39;#btnSend&#39;).click()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 为文本框绑定 keyup 事件</span><br> $(<span class="hljs-string">&#x27;#ipt&#x27;</span>).on(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>   <span class="hljs-comment">// console.log(e.keyCode)</span><br>   <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">13</span>) &#123;<br>     <span class="hljs-comment">// console.log(&#x27;用户弹起了回车键&#x27;)</span><br>     $(<span class="hljs-string">&#x27;#btnSend&#x27;</span>).click()<br>   &#125;<br> &#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/01/28/hello-world/"/>
    <url>/2021/01/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
